/*
Copyright Â© 2026 Soner Astan astansoner@gmail.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package wiregen

import (
	"bytes"
	"errors"
	"fmt"
	"go/build"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/soner3/flora/internal/engine"
	"github.com/soner3/flora/internal/errs"
)

var (
	ErrResolveOutputDir     = errors.New("failed to resolve absolute output directory")
	ErrCreateOutputDir      = errors.New("failed to create output directory")
	ErrMainComponentLeak    = errors.New("component belongs to package 'main' (Go forbids importing main)")
	ErrMainInterfaceLeak    = errors.New("interface belongs to package 'main' (Go forbids importing main)")
	ErrParseTemplate        = errors.New("failed to parse wire template")
	ErrExecuteTemplate      = errors.New("failed to execute wire template")
	ErrWriteTempFile        = errors.New("failed to write temporary wire file")
	ErrEnsureWireDependency = errors.New("failed to ensure google/wire dependency")
	ErrWireExecution        = errors.New("flora engine failed to resolve dependency graph")
	ErrRenameGeneratedFile  = errors.New("failed to rename generated container file")
)

type WireGenerator struct{}

func New() *WireGenerator {
	return &WireGenerator{}
}

var wireTemplate = `//go:build wireinject
// +build wireinject

package {{.PackageName}}

import (
	"github.com/google/wire"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

// FloraContainer holds all configured dependencies.
type FloraContainer struct {
	{{range .Providers}}
	{{.StructName}} {{if .IsPointer}}*{{end}}{{.PackagePrefix}}{{.StructName}}
	{{end}}
}

// InitializeContainer is generated by flora and resolved by Google Wire.
func InitializeContainer() (*FloraContainer, error) {
	wire.Build(
		// 1. Alle Provider (Konstruktoren)
		{{range .Providers}}
		{{.PackagePrefix}}{{.ConstructorName}},
		{{end}}
		
		// 2. Alle Interfaces an die passenden Structs binden
		{{range .Bindings}}
		wire.Bind(new({{.InterfacePrefix}}{{.InterfaceName}}), new({{if .IsPointer}}*{{end}}{{.ComponentPrefix}}{{.StructName}})),
		{{end}}

		// 3. Den Container selbst zusammenbauen
		wire.Struct(new(FloraContainer), "*"),
	)
	return nil, nil
}
`

type providerData struct {
	StructName      string
	PackagePrefix   string
	ConstructorName string
	IsPointer       bool
}

type bindingData struct {
	InterfacePrefix string
	InterfaceName   string
	ComponentPrefix string
	StructName      string
	IsPointer       bool
}

type templateData struct {
	PackageName string
	Imports     []string
	Providers   []providerData
	Bindings    []bindingData
}

func (g *WireGenerator) Generate(outDir string, components []*engine.ComponentMetadata) error {
	log := slog.With("pkg", "wiregen")

	if len(components) == 0 {
		log.Debug("No components provided, skipping generation")
		return nil
	}

	absOutDir, err := filepath.Abs(outDir)
	if err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrResolveOutputDir, err)
		return errs.Wrap(chainErr, "provided path: %s", outDir)
	}

	if err := os.MkdirAll(absOutDir, os.ModePerm); err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrCreateOutputDir, err)
		return errs.Wrap(chainErr, "absolute path: %s", absOutDir)
	}

	pkgName := filepath.Base(absOutDir)
	pkgName = strings.ReplaceAll(pkgName, "-", "_")

	if buildPkg, err := build.Default.ImportDir(absOutDir, 0); err == nil {
		pkgName = buildPkg.Name
	} else if pkgName == "." || pkgName == "/" {
		pkgName = "main"
	}

	data := templateData{
		PackageName: pkgName,
	}

	var providers []providerData
	importSet := make(map[string]bool)
	var bindings []bindingData

	for _, comp := range components {
		compPrefix := ""
		if comp.PackageName != pkgName {
			if comp.PackageName == "main" {
				return errs.Wrap(ErrMainComponentLeak, "cannot generate container in package '%s' because component '%s' belongs to package 'main'. Change output dir (-o) to your main directory or move the component.", pkgName, comp.StructName)
			}
			compPrefix = comp.PackageName + "."
			importSet[comp.PackagePath] = true
		}

		providers = append(providers, providerData{
			StructName:      comp.StructName,
			PackagePrefix:   compPrefix,
			ConstructorName: comp.ConstructorName,
			IsPointer:       comp.IsPointer,
		})

		for _, iface := range comp.Implements {
			ifacePrefix := ""
			if iface.PackageName != pkgName {
				if iface.PackageName == "main" {
					return errs.Wrap(ErrMainInterfaceLeak, "cannot generate container in package '%s' because interface '%s' belongs to package 'main'. Change output dir (-o) to your main directory or move the interface.", pkgName, iface.InterfaceName)
				}
				ifacePrefix = iface.PackageName + "."
				importSet[iface.PackagePath] = true
			}

			bindings = append(bindings, bindingData{
				InterfacePrefix: ifacePrefix,
				InterfaceName:   iface.InterfaceName,
				ComponentPrefix: compPrefix,
				StructName:      comp.StructName,
				IsPointer:       comp.IsPointer,
			})
		}
	}

	data.Providers = providers

	for imp := range importSet {
		data.Imports = append(data.Imports, imp)
	}
	data.Bindings = bindings

	tmpl, err := template.New("wire").Parse(wireTemplate)
	if err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrParseTemplate, err)
		return errs.Wrap(chainErr, "template parsing failed")
	}

	tempFilePath := filepath.Join(absOutDir, "flora_injector.go")
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrExecuteTemplate, err)
		return errs.Wrap(chainErr, "failed to apply data to template")
	}

	log.Debug("Writing temporary wire template", "path", tempFilePath)
	if err := os.WriteFile(tempFilePath, buf.Bytes(), 0644); err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrWriteTempFile, err)
		return errs.Wrap(chainErr, "path: %s", tempFilePath)
	}

	defer os.Remove(tempFilePath)

	log.Debug("Ensuring google/wire dependency is present...")
	getCmd := exec.Command("go", "get", "github.com/google/wire")
	getCmd.Dir = absOutDir
	if err := getCmd.Run(); err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrEnsureWireDependency, err)
		return errs.Wrap(chainErr, "failed running 'go get github.com/google/wire' in %s", absOutDir)
	}

	log.Debug("Running DI engine via Google Wire...")
	cmd := exec.Command("go", "run", "github.com/google/wire/cmd/wire@latest", "gen", ".")
	cmd.Dir = absOutDir

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrWireExecution, err)
		return errs.Wrap(chainErr, "stderr:\n%s", stderr.String())
	}

	generatedWireFile := filepath.Join(absOutDir, "wire_gen.go")
	finalFloraFile := filepath.Join(absOutDir, "flora_container.go")

	log.Debug("Renaming generated file", "from", generatedWireFile, "to", finalFloraFile)
	if err := os.Rename(generatedWireFile, finalFloraFile); err != nil {
		chainErr := fmt.Errorf("%w: %w", ErrRenameGeneratedFile, err)
		return errs.Wrap(chainErr, "from %s to %s", generatedWireFile, finalFloraFile)
	}

	return nil
}
