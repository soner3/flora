/*
Copyright Â© 2026 Soner Astan astansoner@gmail.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package wiregen

import (
	"bytes"
	"go/build"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/soner3/weld/internal/engine"
	"github.com/soner3/weld/internal/errs"
)

type WireGenerator struct{}

func New() *WireGenerator {
	return &WireGenerator{}
}

const wireTemplate = `//go:build wireinject
// +build wireinject

package {{.PackageName}}

import (
	"github.com/google/wire"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

// WeldContainer holds all configured dependencies.
type WeldContainer struct {
	{{range .Providers}}
	{{.StructName}} {{if .IsPointer}}*{{end}}{{.PackagePrefix}}{{.StructName}}
	{{end}}
}

// InitializeContainer is generated by weld and resolved by Google Wire.
func InitializeContainer() (*WeldContainer, error) {
	wire.Build(
		// 1. Alle Provider (Konstruktoren)
		{{range .Providers}}
		{{.PackagePrefix}}{{.ConstructorName}},
		{{end}}
		
		// 2. Alle Interfaces an die passenden Structs binden
		{{range .Bindings}}
		wire.Bind(new({{.InterfacePrefix}}{{.InterfaceName}}), new({{if .IsPointer}}*{{end}}{{.ComponentPrefix}}{{.StructName}})),
		{{end}}

		// 3. Den Container selbst zusammenbauen
		wire.Struct(new(WeldContainer), "*"),
	)
	return nil, nil
}
`

type providerData struct {
	StructName      string
	PackagePrefix   string
	ConstructorName string
	IsPointer       bool
}

type bindingData struct {
	InterfacePrefix string
	InterfaceName   string
	ComponentPrefix string
	StructName      string
	IsPointer       bool
}

type templateData struct {
	PackageName string
	Imports     []string
	Providers   []providerData
	Bindings    []bindingData
}

func (g *WireGenerator) Generate(outDir string, components []*engine.ComponentMetadata) error {
	log := slog.With("pkg", "wiregen")

	if len(components) == 0 {
		log.Debug("No components provided, skipping generation")
		return nil
	}

	absOutDir, err := filepath.Abs(outDir)
	if err != nil {
		return errs.Wrap(err, "failed to resolve absolute output directory")
	}

	if err := os.MkdirAll(absOutDir, os.ModePerm); err != nil {
		return errs.Wrap(err, "failed to create output directory")
	}

	pkgName := filepath.Base(absOutDir)
	pkgName = strings.ReplaceAll(pkgName, "-", "_")

	if buildPkg, err := build.Default.ImportDir(absOutDir, 0); err == nil {
		pkgName = buildPkg.Name
	} else if pkgName == "." || pkgName == "/" {
		pkgName = "main"
	}

	data := templateData{
		PackageName: pkgName,
	}

	var providers []providerData
	importSet := make(map[string]bool)
	var bindings []bindingData

	for _, comp := range components {
		compPrefix := ""
		if comp.PackageName != pkgName {
			if comp.PackageName == "main" {
				return errs.Wrap(nil, "cannot generate container in package '%s' because component '%s' belongs to package 'main' (Go forbids importing main). Change output dir (-o) to your main directory or move the component.", pkgName, comp.StructName)
			}
			compPrefix = comp.PackageName + "."
			importSet[comp.PackagePath] = true
		}

		providers = append(providers, providerData{
			StructName:      comp.StructName,
			PackagePrefix:   compPrefix,
			ConstructorName: comp.ConstructorName,
			IsPointer:       comp.IsPointer,
		})

		for _, iface := range comp.Implements {
			ifacePrefix := ""
			if iface.PackageName != pkgName {
				if iface.PackageName == "main" {
					return errs.Wrap(nil, "cannot generate container in package '%s' because interface '%s' belongs to package 'main'. Change output dir (-o) to your main directory or move the interface.", pkgName, iface.InterfaceName)
				}
				ifacePrefix = iface.PackageName + "."
				importSet[iface.PackagePath] = true
			}

			bindings = append(bindings, bindingData{
				InterfacePrefix: ifacePrefix,
				InterfaceName:   iface.InterfaceName,
				ComponentPrefix: compPrefix,
				StructName:      comp.StructName,
				IsPointer:       comp.IsPointer,
			})
		}
	}

	data.Providers = providers

	for imp := range importSet {
		data.Imports = append(data.Imports, imp)
	}
	data.Bindings = bindings

	tmpl, err := template.New("wire").Parse(wireTemplate)
	if err != nil {
		return errs.Wrap(err, "failed to parse wire template")
	}

	tempFilePath := filepath.Join(absOutDir, "weld_injector.go")
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return errs.Wrap(err, "failed to execute wire template")
	}

	log.Debug("Writing temporary wire template", "path", tempFilePath)
	if err := os.WriteFile(tempFilePath, buf.Bytes(), 0644); err != nil {
		return errs.Wrap(err, "failed to write temporary wire file")
	}

	defer os.Remove(tempFilePath)

	log.Debug("Ensuring google/wire dependency is present...")
	getCmd := exec.Command("go", "get", "github.com/google/wire")
	getCmd.Dir = absOutDir
	if err := getCmd.Run(); err != nil {
		log.Debug("go get github.com/google/wire returned an error (ignoring)", "error", err)
	}

	log.Debug("Running DI engine via Google Wire...")
	cmd := exec.Command("go", "run", "github.com/google/wire/cmd/wire@latest", "gen", ".")
	cmd.Dir = absOutDir

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return errs.Wrap(err, "weld engine failed to resolve dependency graph:\n%s", stderr.String())
	}

	generatedWireFile := filepath.Join(absOutDir, "wire_gen.go")
	finalWeldFile := filepath.Join(absOutDir, "weld_container.go")

	log.Debug("Renaming generated file", "from", generatedWireFile, "to", finalWeldFile)
	if err := os.Rename(generatedWireFile, finalWeldFile); err != nil {
		return errs.Wrap(err, "failed to rename generated container file")
	}

	return nil
}
