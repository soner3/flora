/*
Copyright Â© 2026 Soner Astan astansoner@gmail.com

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package wiregen

import (
	"bytes"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/soner3/weld/internal/engine"
	"github.com/soner3/weld/internal/errs"
)

type WireGenerator struct{}

func New() *WireGenerator {
	return &WireGenerator{}
}

const wireTemplate = `//go:build wireinject
// +build wireinject

package {{.PackageName}}

import (
	"github.com/google/wire"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

// WeldContainer holds all configured dependencies.
type WeldContainer struct {
	{{range .Providers}}
	{{if .IsPointer}}
	{{.StructName}} *{{.PackageName}}.{{.StructName}}
	{{else}}
	{{.StructName}} {{.PackageName}}.{{.StructName}}
	{{end}}
	{{end}}
}

// InitializeContainer is generated by weld and resolved by Google Wire.
func InitializeContainer() (*WeldContainer, error) {
	wire.Build(
		// 1. Alle Provider (Konstruktoren)
		{{range .Providers}}
		{{.PackageName}}.{{.ConstructorName}},
		{{end}}
		
		// 2. Alle Interfaces an die passenden Structs binden
		{{range .Bindings}}
		wire.Bind(new({{.InterfacePkg}}.{{.InterfaceName}}), new({{if .IsPointer}}*{{end}}{{.ComponentPkg}}.{{.StructName}})),
		{{end}}

		// 3. Den Container selbst zusammenbauen
		wire.Struct(new(WeldContainer), "*"),
	)
	return nil, nil
}
`

type templateData struct {
	PackageName string
	Imports     []string
	Providers   []*engine.ComponentMetadata
	Bindings    []bindingData
}

type bindingData struct {
	InterfacePkg  string
	InterfaceName string
	ComponentPkg  string
	StructName    string
	IsPointer     bool
}

func (g *WireGenerator) Generate(targetDir string, components []*engine.ComponentMetadata) error {
	log := slog.With("pkg", "wiregen")

	if len(components) == 0 {
		log.Debug("No components provided, skipping generation")
		return nil
	}

	weldPkgDir := filepath.Join(targetDir, "weld")
	if err := os.MkdirAll(weldPkgDir, os.ModePerm); err != nil {
		return errs.Wrap(err, "failed to create weld package directory")
	}

	data := templateData{
		PackageName: "weld",
		Providers:   components,
	}

	importSet := make(map[string]bool)
	var bindings []bindingData

	for _, comp := range components {
		importSet[comp.PackagePath] = true
		for _, iface := range comp.Implements {
			importSet[iface.PackagePath] = true
			bindings = append(bindings, bindingData{
				InterfacePkg:  iface.PackageName,
				InterfaceName: iface.InterfaceName,
				ComponentPkg:  comp.PackageName,
				StructName:    comp.StructName,
				IsPointer:     comp.IsPointer,
			})
		}
	}

	for imp := range importSet {
		data.Imports = append(data.Imports, imp)
	}
	data.Bindings = bindings

	tmpl, err := template.New("wire").Parse(wireTemplate)
	if err != nil {
		return errs.Wrap(err, "failed to parse wire template")
	}

	tempFilePath := filepath.Join(weldPkgDir, "weld_injector.go")
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return errs.Wrap(err, "failed to execute wire template")
	}

	log.Debug("Writing temporary wire template", "path", tempFilePath)
	if err := os.WriteFile(tempFilePath, buf.Bytes(), 0644); err != nil {
		return errs.Wrap(err, "failed to write temporary wire file")
	}

	defer os.Remove(tempFilePath)

	log.Debug("Running DI engine via Google Wire...")

	cmd := exec.Command("go", "run", "github.com/google/wire/cmd/wire@latest", "gen", ".")
	cmd.Dir = weldPkgDir

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return errs.Wrap(err, "weld engine failed to resolve dependency graph:\n%s", stderr.String())
	}

	generatedWireFile := filepath.Join(weldPkgDir, "wire_gen.go")
	finalWeldFile := filepath.Join(weldPkgDir, "weld_container.go")

	log.Debug("Renaming generated file", "from", generatedWireFile, "to", finalWeldFile)
	if err := os.Rename(generatedWireFile, finalWeldFile); err != nil {
		return errs.Wrap(err, "failed to rename generated container file")
	}

	return nil
}
